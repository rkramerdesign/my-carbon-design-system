/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var isEqual = require('react-fast-compare');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

const callOnChangeHandler = ({
  isControlled,
  isMounted,
  onChangeHandlerControlled,
  onChangeHandlerUncontrolled,
  selectedItems
}) => {
  if (isControlled) {
    if (isMounted && onChangeHandlerControlled) {
      onChangeHandlerControlled({
        selectedItems
      });
    }
  } else {
    onChangeHandlerUncontrolled(selectedItems);
  }
};
const useSelection = ({
  disabled,
  onChange,
  initialSelectedItems = [],
  selectedItems: controlledItems,
  selectAll = false,
  filteredItems = []
}) => {
  const isMounted = React.useRef(false);
  const savedOnChange = React.useRef(onChange);
  const [uncontrolledItems, setUncontrolledItems] = React.useState(initialSelectedItems);
  const isControlled = !!controlledItems;
  const selectedItems = isControlled ? controlledItems : uncontrolledItems;
  const onItemChange = React.useCallback(item => {
    if (disabled) return;

    // Assert special properties (e.g., `disabled`, `isSelectAll`, etc.) are
    // `any` since those properties arenâ€™t part of the generic type.
    const allSelectableItems = filteredItems.filter(item => !item?.disabled);
    const disabledItemCount = filteredItems.filter(item => item?.disabled).length;
    let newSelectedItems;

    // deselect all on click to All/indeterminate option
    if (item?.isSelectAll && selectedItems.length > 0) {
      newSelectedItems = [];
    }
    // select all options
    else if (item?.isSelectAll && selectedItems.length === 0) {
      newSelectedItems = allSelectableItems;
    } else {
      const selectedIndex = selectedItems.findLastIndex(selectedItem => isEqual__default["default"](selectedItem, item));
      if (selectedIndex === -1) {
        newSelectedItems = selectedItems.concat(item);
        // checking if all items are selected then We should select mark the 'select All' option as well
        if (selectAll && filteredItems.length - 1 === newSelectedItems.length + disabledItemCount) {
          newSelectedItems = allSelectableItems;
        }
      } else {
        newSelectedItems = removeAtIndex(selectedItems, selectedIndex);
        newSelectedItems = newSelectedItems.filter(item => !item?.isSelectAll);
      }
    }
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: newSelectedItems
    });
  }, [disabled, selectedItems, filteredItems, selectAll, isControlled]);
  const clearSelection = React.useCallback(() => {
    if (disabled) return;
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: []
    });
  }, [disabled, isControlled]);
  React.useEffect(() => {
    savedOnChange.current = onChange;
  }, [onChange]);
  React.useEffect(() => {
    if (isMounted.current && savedOnChange.current && !isControlled) {
      savedOnChange.current({
        selectedItems
      });
    }
  }, [isControlled, selectedItems]);
  React.useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return {
    clearSelection,
    onItemChange,
    selectedItems
  };
};

/**
 * Generic utility for safely removing an element at a given index from an
 * array.
 */
const removeAtIndex = (array, index) => {
  const result = array.slice();
  result.splice(index, 1);
  return result;
};

exports.useSelection = useSelection;
